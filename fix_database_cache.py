"""
MarketPulse Database Fix - Clear Cache and Rebuild
Clears Python cache and creates a fresh SQLite-compatible models file

Usage: python fix_database_cache.py
"""

import sys
import shutil
from pathlib import Path
import os


def clear_python_cache():
    """Clear Python cache files"""

    print("🧹 Clearing Python cache...")

    current_dir = Path.cwd()
    cache_dirs = []

    # Find all __pycache__ directories
    for root, dirs, files in os.walk(current_dir):
        if '__pycache__' in dirs:
            cache_path = Path(root) / '__pycache__'
            cache_dirs.append(cache_path)

    # Remove cache directories
    for cache_dir in cache_dirs:
        try:
            shutil.rmtree(cache_dir)
            print(f"   ✅ Removed: {cache_dir}")
        except Exception as e:
            print(f"   ⚠️ Could not remove {cache_dir}: {e}")

    # Remove .pyc files
    pyc_files = []
    for root, dirs, files in os.walk(current_dir):
        for file in files:
            if file.endswith('.pyc'):
                pyc_path = Path(root) / file
                pyc_files.append(pyc_path)

    for pyc_file in pyc_files:
        try:
            pyc_file.unlink()
            print(f"   ✅ Removed: {pyc_file}")
        except Exception as e:
            print(f"   ⚠️ Could not remove {pyc_file}: {e}")

    print(f"🧹 Cache cleanup complete: {len(cache_dirs)} dirs, {len(pyc_files)} files")


def create_fresh_models():
    """Create a completely fresh models.py file"""

    print("📄 Creating fresh models.py...")

    models_content = '''"""
MarketPulse Database Models - Fresh SQLite Compatible Version
No JSONB, no PostgreSQL imports, pure SQLite

Generated by fix_database_cache.py
"""

from datetime import datetime
from sqlalchemy import (
    Column, Integer, Float, String, DateTime, Boolean, 
    Text, ForeignKey, Index, UniqueConstraint, CheckConstraint
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.ext.declarative import declarative_base
import uuid
import json

# Create Base
Base = declarative_base()

class MarketData(Base):
    """Market data - OHLCV time series"""
    __tablename__ = 'market_data'

    id = Column(Integer, primary_key=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, index=True)
    timeframe = Column(String(10), nullable=False)

    open_price = Column(Float, nullable=False)
    high_price = Column(Float, nullable=False)
    low_price = Column(Float, nullable=False)
    close_price = Column(Float, nullable=False)
    volume = Column(Integer, nullable=False)

    data_source = Column(String(50), nullable=False)
    created_at = Column(DateTime, default=func.now())

    __table_args__ = (
        Index('idx_market_data_symbol_time', 'symbol', 'timestamp'),
        UniqueConstraint('symbol', 'timestamp', 'timeframe')
    )

class Portfolio(Base):
    """Portfolio management"""
    __tablename__ = 'portfolios'

    portfolio_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String(100), nullable=False)
    portfolio_type = Column(String(20), nullable=False)

    total_capital = Column(Float, nullable=False)
    available_capital = Column(Float, nullable=False)
    invested_capital = Column(Float, nullable=False)
    unrealized_pnl = Column(Float, default=0.0)
    realized_pnl = Column(Float, default=0.0)

    total_trades = Column(Integer, default=0)
    winning_trades = Column(Integer, default=0)
    losing_trades = Column(Integer, default=0)

    created_at = Column(DateTime, default=func.now())

    snapshots = relationship("PortfolioSnapshot", back_populates="portfolio")

class Trade(Base):
    """Trade records"""
    __tablename__ = 'trades'

    trade_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    symbol = Column(String(20), nullable=False, index=True)
    strategy = Column(String(50), nullable=False)

    action = Column(String(10), nullable=False)  # BUY, SELL
    quantity = Column(Integer, nullable=False)
    entry_price = Column(Float, nullable=False)
    exit_price = Column(Float)

    status = Column(String(20), nullable=False, default='ACTIVE')

    gross_pnl = Column(Float, default=0.0)
    commission = Column(Float, default=0.0)
    net_pnl = Column(Float, default=0.0)
    return_pct = Column(Float, default=0.0)

    entry_timestamp = Column(DateTime, nullable=False, default=func.now())
    exit_timestamp = Column(DateTime)
    created_at = Column(DateTime, default=func.now())

    __table_args__ = (
        CheckConstraint("action IN ('BUY', 'SELL')"),
        CheckConstraint("quantity > 0"),
        Index('idx_trades_symbol_time', 'symbol', 'entry_timestamp'),
    )

class Signal(Base):
    """Trading signals"""
    __tablename__ = 'signals'

    signal_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    symbol = Column(String(20), nullable=False, index=True)
    strategy = Column(String(50), nullable=False)

    direction = Column(String(10), nullable=False)  # BUY, SELL, HOLD
    strength = Column(Float, nullable=False)
    confidence = Column(Float, nullable=False)

    current_price = Column(Float, nullable=False)
    predicted_target = Column(Float)
    predicted_stop_loss = Column(Float)

    executed = Column(Boolean, default=False)
    timestamp = Column(DateTime, nullable=False, default=func.now(), index=True)
    created_at = Column(DateTime, default=func.now())

    trades = relationship("Trade")

    __table_args__ = (
        CheckConstraint("direction IN ('BUY', 'SELL', 'HOLD')"),
        CheckConstraint("strength >= 0.0 AND strength <= 1.0"),
        CheckConstraint("confidence >= 0.0 AND confidence <= 1.0"),
    )

class PortfolioSnapshot(Base):
    """Daily portfolio snapshots"""
    __tablename__ = 'portfolio_snapshots'

    snapshot_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    portfolio_id = Column(String(36), ForeignKey('portfolios.portfolio_id'))

    snapshot_date = Column(DateTime, nullable=False, index=True)
    total_value = Column(Float, nullable=False)
    available_cash = Column(Float, nullable=False)
    daily_pnl = Column(Float, default=0.0)
    daily_return_pct = Column(Float, default=0.0)

    created_at = Column(DateTime, default=func.now())

    portfolio = relationship("Portfolio", back_populates="snapshots")

    __table_args__ = (
        UniqueConstraint('portfolio_id', 'snapshot_date'),
    )

class AlphaModelPrediction(Base):
    """ML model predictions (SQLite compatible)"""
    __tablename__ = 'alpha_predictions'

    prediction_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    symbol = Column(String(20), nullable=False, index=True)
    model_name = Column(String(50), nullable=False)

    # Store JSON as text strings
    features = Column(Text)  # JSON stored as text
    feature_importance = Column(Text)  # JSON stored as text

    predicted_direction = Column(String(10))
    probability_profitable = Column(Float)
    predicted_return_pct = Column(Float)
    model_confidence = Column(Float)

    actual_direction = Column(String(10))
    actual_return_pct = Column(Float)
    prediction_accuracy = Column(Float)

    timestamp = Column(DateTime, nullable=False, default=func.now(), index=True)
    created_at = Column(DateTime, default=func.now())

    def set_features(self, features_dict):
        """Store features as JSON string"""
        self.features = json.dumps(features_dict) if features_dict else None

    def get_features(self):
        """Get features as dict"""
        return json.loads(self.features) if self.features else {}

class TechnicalIndicator(Base):
    """Technical indicators"""
    __tablename__ = 'technical_indicators'

    indicator_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    symbol = Column(String(20), nullable=False, index=True)
    timeframe = Column(String(10), nullable=False)
    timestamp = Column(DateTime, nullable=False, index=True)

    # Technical indicators
    rsi_14 = Column(Float)
    macd = Column(Float)
    macd_signal = Column(Float)
    sma_20 = Column(Float)
    sma_50 = Column(Float)
    bb_upper = Column(Float)
    bb_lower = Column(Float)
    atr_14 = Column(Float)
    volume_ratio = Column(Float)

    created_at = Column(DateTime, default=func.now())

    __table_args__ = (
        UniqueConstraint('symbol', 'timeframe', 'timestamp'),
    )

class SystemLog(Base):
    """System logs"""
    __tablename__ = 'system_logs'

    log_id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    level = Column(String(10), nullable=False)
    module = Column(String(50), nullable=False)
    event_type = Column(String(50), nullable=False)
    message = Column(Text, nullable=False)

    # Store JSON as text
    context = Column(Text)  # JSON as text

    timestamp = Column(DateTime, nullable=False, default=func.now(), index=True)

    def set_context(self, context_dict):
        """Store context as JSON string"""
        self.context = json.dumps(context_dict) if context_dict else None

    def get_context(self):
        """Get context as dict"""
        return json.loads(self.context) if self.context else {}

# Export all models
__all__ = [
    'Base', 'MarketData', 'Portfolio', 'Trade', 'Signal',
    'PortfolioSnapshot', 'AlphaModelPrediction', 'TechnicalIndicator', 'SystemLog'
]
'''

    # Write to models.py
    models_path = Path.cwd() / "06_DATA" / "database" / "models.py"
    models_path.parent.mkdir(parents=True, exist_ok=True)

    with open(models_path, 'w') as f:
        f.write(models_content)

    print(f"✅ Fresh models.py created: {models_path}")


def test_fresh_database():
    """Test the fresh database setup"""

    print("🧪 Testing fresh database...")

    try:
        # Add to path
        sys.path.insert(0, str(Path.cwd() / "06_DATA"))

        # Import fresh models
        from database.models import Base, MarketData, Portfolio
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
        from datetime import datetime

        # Create database
        db_path = Path.cwd() / "fresh_test.db"
        engine = create_engine(f"sqlite:///{db_path}")

        # Create tables
        Base.metadata.create_all(bind=engine)
        print("✅ Tables created successfully")

        # Test session
        Session = sessionmaker(bind=engine)
        session = Session()

        # Insert test data
        market_data = MarketData(
            symbol='FRESH_TEST',
            timestamp=datetime.now(),
            timeframe='1d',
            open_price=100.0,
            high_price=105.0,
            low_price=95.0,
            close_price=102.0,
            volume=10000,
            data_source='fresh_test'
        )

        session.add(market_data)
        session.commit()

        # Query back
        result = session.query(MarketData).filter(MarketData.symbol == 'FRESH_TEST').first()
        if result:
            print(f"✅ Fresh database test passed: {result.symbol} @ {result.close_price}")

        session.close()
        return True

    except Exception as e:
        print(f"❌ Fresh database test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def main():
    """Main fix function"""

    print("🔧 MarketPulse Database Cache Fix")
    print("=" * 40)

    # Step 1: Clear cache
    clear_python_cache()

    # Step 2: Create fresh models
    create_fresh_models()

    # Step 3: Test fresh database
    if test_fresh_database():
        print("\n🎉 Database fix successful!")
        print("✅ Fresh SQLite-compatible models created")
        print("✅ Python cache cleared")
        print("✅ Database test passed")

        print("\n📋 Now try:")
        print("   python hybrid_database_setup.py")

        return True
    else:
        print("\n❌ Database fix failed")
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)